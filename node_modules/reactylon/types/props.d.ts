import type { ActionEvent, HighlightLayer, Node, Observable, Scene, StandardMaterial } from '@babylonjs/core';
import type { Either } from './types';
import type { AdvancedDynamicTexture, Grid, Vector2WithInfo } from '@babylonjs/gui';
type TransformType = 'position' | 'rotation' | 'scaling';
type Axis = 'X' | 'Y' | 'Z';
export type TransformKeys = Record<`${TransformType}${Axis}`, `${TransformType}.${Lowercase<Axis>}`>;
export type TransformProps = Record<`${TransformType}${Axis}`, number>;
export declare enum BabylonElements {
    MESH = 0,
    NODE = 1,
    LIGHT = 2,
    CAMERA = 3,
    TEXTURE = 4,
    MATERIAL = 5
}
export type CommonProps<T = unknown> = Partial<TransformProps> & {
    binding?: T;
    onCreate?: (element: T) => void;
    scene?: Scene;
    propertiesFrom?: Array<{
        property: string;
        source: string;
        type: BabylonElements;
    }>;
};
export declare enum GuiTriggers {
    onPointerMove = "onPointerMoveObservable",
    onPointerEnter = "onPointerEnterObservable",
    onPointerOut = "onPointerOutObservable",
    onPointerDown = "onPointerDownObservable",
    onPointerUp = "onPointerUpObservable",
    onPointerClick = "onPointerClickObservable",
    onClipboard = "onClipboardObservable"
}
export type GuiTriggerable = {
    [key in keyof typeof GuiTriggers]?: Parameters<Observable<Vector2WithInfo>['add']>[0];
};
export declare enum MeshTriggers {
    onPick,
    onDoublePick,
    onPickDown,
    onPickUp,
    onPickOut,
    onLeftPick,
    onRightPick,
    onCenterPick,
    onLongPress,
    onPointerOver,
    onPointerOut,
    onIntersectionEnter,
    onIntersectionExit
}
export type Triggerable = {
    [key in keyof typeof MeshTriggers]?: (evt: ActionEvent) => void;
} & {
    intersectionMeshId?: string;
};
export type Clonable = {
    cloneFrom: string;
};
export type Instanceable = {
    instanceFrom: string;
};
export type TextureProps = {
    kind: keyof Pick<StandardMaterial, 'diffuseTexture' | 'specularTexture' | 'emissiveTexture' | 'ambientTexture' | 'bumpTexture' | 'opacityTexture' | 'reflectionTexture' | 'refractionTexture' | 'detailMap'> | (string & {});
};
type CreateFullscreeUIOptions = {
    createFullscreenUI: {
        name: Parameters<typeof AdvancedDynamicTexture.CreateFullscreenUI>[0];
        foreground?: Parameters<typeof AdvancedDynamicTexture.CreateFullscreenUI>[1];
        scene?: Parameters<typeof AdvancedDynamicTexture.CreateFullscreenUI>[2];
        sampling?: Parameters<typeof AdvancedDynamicTexture.CreateFullscreenUI>[3];
        adaptiveScaling?: Parameters<typeof AdvancedDynamicTexture.CreateFullscreenUI>[4];
    };
};
type CreateForMeshOptions = {
    createForMesh: {
        mesh: string;
        width?: Parameters<typeof AdvancedDynamicTexture.CreateForMesh>[1];
        height?: Parameters<typeof AdvancedDynamicTexture.CreateForMesh>[2];
        supportPointerMove?: Parameters<typeof AdvancedDynamicTexture.CreateForMesh>[3];
        onlyAlphaTesting?: Parameters<typeof AdvancedDynamicTexture.CreateForMesh>[4];
        invertY?: Parameters<typeof AdvancedDynamicTexture.CreateForMesh>[5];
        materialSetupCallback?: Parameters<typeof AdvancedDynamicTexture.CreateForMesh>[6];
    };
};
type CreateForMeshProps = CreateForMeshOptions & {
    name?: string;
};
export type AdvancedDynamicTextureProps = Either<CreateFullscreeUIOptions, CreateForMeshProps> & {
    kind: 'createFullscreenUI' | 'createForMesh';
};
export type LightProps = Clonable;
export type CameraProps = {
    canvas?: HTMLCanvasElement;
};
export type WebXRCameraProps = {
    isManual?: boolean;
};
export type MaterialProps = Partial<Clonable> & {
    assignTo?: Array<string>;
};
export type MeshProps = Either<Clonable, Instanceable> & Triggerable & {
    highlightLayer?: {
        color: Parameters<HighlightLayer['addMesh']>[1];
        glowEmissiveOnly?: Parameters<HighlightLayer['addMesh']>[2];
    };
};
export type GuiProps = GuiTriggerable & {};
export type RowProps = {
    height: Parameters<Grid['addRowDefinition']>[0];
    isPixel?: Parameters<Grid['addRowDefinition']>[1];
} & GuiProps;
export type ColumnProps = {
    width: Parameters<Grid['addColumnDefinition']>[0];
    isPixel?: Parameters<Grid['addColumnDefinition']>[1];
} & GuiProps;
type MinimalHostProps = CommonProps & Pick<Node, 'name'>;
export type CoreHostProps<T = undefined> = T extends undefined ? MinimalHostProps : MinimalHostProps & T;
export type GuiHostProps<T = undefined> = (T extends undefined ? MinimalHostProps : MinimalHostProps & T) & GuiProps;
export {};
